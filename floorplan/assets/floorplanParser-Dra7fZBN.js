class t{#t={defaultWallHeight:3,defaultWallThickness:.15,defaultDoorHeight:2.1,defaultWindowHeight:1.2,defaultWindowSillHeight:.9,defaultCeilingHeight:3,pixelsPerMeter:50,mergeThreshold:.1,minimumWallLength:.3,minimumRoomArea:2};#o=null;#i=null;constructor(t={}){this.#t={...this.#t,...t}}async parseFloorPlan(t){try{this.#e(t),t.scale&&(this.#t.pixelsPerMeter=t.scale),this.#n(t.dimensions);const o=await this.#s(t.walls),i=await this.#r(t.doors,o),e=await this.#a(t.windows,o),n=await this.#l(t.rooms),s=this.#c(o),r=this.#h(n,i,e),a={walls:s,doors:i,windows:e,rooms:r,floors:this.#d(r),ceilings:this.#x(r),metadata:{scale:this.#t.pixelsPerMeter,bounds:this.#o,wallHeight:this.#t.defaultWallHeight,wallThickness:this.#t.defaultWallThickness}};return this.#y(a),a}catch(o){throw new Error(`Floor plan parsing failed: ${o.message}`)}}#e(t){const o=["dimensions","walls","doors","windows","rooms"];for(const i of o)if(!(i in t))throw new Error(`Missing required field: ${i}`);if(!t.dimensions.width||!t.dimensions.height)throw new Error("Invalid image dimensions");if(!Array.isArray(t.walls))throw new Error("Walls must be an array")}#n(t){const{width:o,height:i}=t,e=this.#t.pixelsPerMeter,n=o/e,s=i/e;this.#o={width:n,height:s,minX:-n/2,maxX:n/2,minY:-s/2,maxY:s/2},this.#i={pixelToWorld:(t,o)=>({x:t/e-n/2,y:s/2-o/e,z:0}),worldToPixel:(t,o)=>({x:(t+n/2)*e,y:(s/2-o)*e})}}async#s(t){const o=[];for(const e of t)try{const t=await this.#m(e);t&&t.length>=this.#t.minimumWallLength&&o.push(t)}catch(i){}return o}async#m(t){const{start:o,end:i,orientation:e}=t,n=this.#i.pixelToWorld(o.x,o.y),s=this.#i.pixelToWorld(i.x,i.y),r=Math.sqrt(Math.pow(s.x-n.x,2)+Math.pow(s.y-n.y,2)),a={x:(s.x-n.x)/r,y:(s.y-n.y)/r,z:0},l={x:-a.y,y:a.x,z:0},c=this.#t.defaultWallThickness,h=this.#t.defaultWallHeight,d=this.#g(n,s,l,c,h);return{id:`wall_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,type:"wall",start:n,end:s,direction:a,normal:l,length:r,thickness:c,height:h,orientation:e,vertices:d,faces:this.#f(d),openings:[]}}#g(t,o,i,e,n){const s=e/2;return[{x:t.x-i.x*s,y:0,z:t.y-i.y*s},{x:t.x+i.x*s,y:0,z:t.y+i.y*s},{x:o.x+i.x*s,y:0,z:o.y+i.y*s},{x:o.x-i.x*s,y:0,z:o.y-i.y*s},{x:t.x-i.x*s,y:n,z:t.y-i.y*s},{x:t.x+i.x*s,y:n,z:t.y+i.y*s},{x:o.x+i.x*s,y:n,z:o.y+i.y*s},{x:o.x-i.x*s,y:n,z:o.y-i.y*s}]}#f(t){return[[0,1,2],[0,2,3],[4,6,5],[4,7,6],[0,4,5],[0,5,1],[2,6,7],[2,7,3],[3,7,4],[3,4,0],[1,5,6],[1,6,2]]}async#r(t,o){const i=[];for(const n of t)try{const t=await this.#u(n,o);if(t){i.push(t);const e=o.find((o=>o.id===t.wallId));e&&e.openings.push(t)}}catch(e){}return i}async#u(t,o){const{position:i,width:e,orientation:n}=t,s=this.#i.pixelToWorld(i.x,i.y),r=this.#p(s,o);if(!r)return null;const a=e/this.#t.pixelsPerMeter,l=this.#t.defaultDoorHeight,c=this.#w(s,r);return{id:`door_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,type:"door",position:c,width:a,height:l,thickness:r.thickness,orientation:n,wallId:r.id,opening:this.#z(c,a,l,r)}}async#a(t,o){const i=[];for(const n of t)try{const t=await this.#W(n,o);if(t){i.push(t);const e=o.find((o=>o.id===t.wallId));e&&e.openings.push(t)}}catch(e){}return i}async#W(t,o){const{position:i,width:e,orientation:n}=t,s=this.#i.pixelToWorld(i.x,i.y),r=this.#p(s,o);if(!r)return null;const a=e/this.#t.pixelsPerMeter,l=this.#t.defaultWindowHeight,c=this.#t.defaultWindowSillHeight,h=this.#w(s,r);return{id:`window_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,type:"window",position:h,width:a,height:l,sillHeight:c,thickness:r.thickness,orientation:n,wallId:r.id,opening:this.#z({...h,y:c},a,l,r)}}async#l(t){const o=[];for(const e of t)try{const t=await this.#T(e);t&&t.area>=this.#t.minimumRoomArea&&o.push(t)}catch(i){}return o}async#T(t){const{bounds:o,area:i,center:e}=t,n=this.#i.pixelToWorld(o.minX,o.minY),s=this.#i.pixelToWorld(o.maxX,o.maxY),r=this.#i.pixelToWorld(e.x,e.y),a=Math.abs(s.x-n.x),l=Math.abs(s.z-n.z),c=i/(this.#t.pixelsPerMeter*this.#t.pixelsPerMeter);return{id:`room_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,type:"room",center:r,bounds:{min:n,max:s},dimensions:{width:a,depth:l},area:c,floor:this.#M(n,s),ceiling:this.#D(n,s)}}#p(t,o){let i=null,e=1/0;for(const n of o){const o=this.#v(t,n);o<e&&(e=o,i=n)}return e<this.#t.mergeThreshold?i:null}#v(t,o){const{start:i,end:e}=o,n=t.x-i.x,s=t.z-i.y,r=e.x-i.x,a=e.y-i.y,l=n*r+s*a,c=r*r+a*a;if(0===c)return Math.sqrt(n*n+s*s);let h=l/c;h=Math.max(0,Math.min(1,h));const d=i.x+h*r,x=i.y+h*a,y=t.x-d,m=t.z-x;return Math.sqrt(y*y+m*m)}#w(t,o){const{start:i,end:e}=o,n=t.x-i.x,s=t.z-i.y,r=e.x-i.x,a=e.y-i.y,l=n*r+s*a,c=r*r+a*a;if(0===c)return{x:i.x,y:0,z:i.y};let h=l/c;return h=Math.max(0,Math.min(1,h)),{x:i.x+h*r,y:0,z:i.y+h*a}}#z(t,o,i,e){const n=o/2,{normal:s,thickness:r}=e;return{vertices:[{x:t.x-n,y:t.y,z:t.z},{x:t.x+n,y:t.y,z:t.z},{x:t.x+n,y:t.y+i,z:t.z},{x:t.x-n,y:t.y+i,z:t.z}],bounds:{min:{x:t.x-n,y:t.y,z:t.z-r/2},max:{x:t.x+n,y:t.y+i,z:t.z+r/2}}}}#M(t,o){return{vertices:[{x:t.x,y:0,z:t.z},{x:o.x,y:0,z:t.z},{x:o.x,y:0,z:o.z},{x:t.x,y:0,z:o.z}],faces:[[0,1,2],[0,2,3]]}}#D(t,o){const i=this.#t.defaultCeilingHeight;return{vertices:[{x:t.x,y:i,z:t.z},{x:o.x,y:i,z:t.z},{x:o.x,y:i,z:o.z},{x:t.x,y:i,z:o.z}],faces:[[0,2,1],[0,3,2]]}}#c(t){return[...t]}#h(t,o,i){return t.map((t=>({...t,openings:[...o,...i].filter((o=>this.#P(o,t)))})))}#P(t,o){const{position:i}=t,{bounds:e}=o;return i.x>=e.min.x&&i.x<=e.max.x&&i.z>=e.min.z&&i.z<=e.max.z}#d(t){return t.map((t=>({id:`floor_${t.id}`,roomId:t.id,...t.floor})))}#x(t){return t.map((t=>({id:`ceiling_${t.id}`,roomId:t.id,...t.ceiling})))}#y(t){if(!t.walls||!Array.isArray(t.walls))throw new Error("Invalid walls data in model");if(!t.metadata||!t.metadata.bounds)throw new Error("Missing model metadata")}updateConfig(t){this.#t={...this.#t,...t}}getConfig(){return{...this.#t}}}export{t as default};
